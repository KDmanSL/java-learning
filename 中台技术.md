1. 中台技术
   业务中台：微服务 ddd领域驱动开发
   数据中台：大数据 spark Hadoop

2. SOA架构与微服务：都是将系统分解成多个服务（分布式思想）
   服务粒度：SOA服务粒度要大一些，可能一个服务模块中包含有多个功能模块，但微服务服务粒度很小，基本上一个服务只负责一个特定的功能。

3. CQRS架构：读写分离思想，将数据的查询与增删改分开，通过不同渠道进行读写。

4. 失血模型与充血模型：
   失血模型：数据对象中只有简单是setter和getter，没有业务方法
   充血模型：业务方法定义在实体对象中

5. AOP面向切面编程，OOP面向对象编程，OOD面向对象设计，OOA面向对象分析

6. 敏捷开发：大系统拆分成小的项目，然后系统持续可以运行，只需要不断完善各个小功能，后续不断完善，用户需求为核心，不断迭代。

7. CI/CD：一个流程，持续集成，持续部署，持续交付。用于实现应用开发中的高度持续自动化和持续监控，形如github代码维护平台，以及docker环境

8. Xen ：虚拟化技术 与linux有很好的适配性，有半虚拟和完全虚拟

9. Netty：JAVA编程网络框架；与TOMCAT对比：tomcat基于HTTP协议，netty可自定义各种协议。都是基于NIO（非阻塞式IO）

10. 事务的四大特性：ACID 原子性 一致性 隔离性 持久性 

11. 数据库范式
    第一范式：原子性
    第二范式：消除非主属性部分函数依赖
    第三范式：消除非主属性传递函数依赖
    BC范式：消除主属性与非主属性的部分函数依赖和传递函数依赖

12. 数据库隔离级别：
    ![image-20210822180308501](https://camo.githubusercontent.com/a23e3685e5a71a44b686a9fbc4e6d908b1d842065a9c8d65b0e514f92a710614/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303832323138303330383530312e706e67)
    脏读：事务A读到事务B更新了数据，然后B回滚操作，A读到的就是脏数据
    不可重复读：A在不断读某一个数据时，这个数据被修改，就导致读出的数据不一致
    幻读：A在修改数据时，B进行了数据的增加和删除，导致新增的数据出现问题

    READ-UNCOMMITTED读未提交内容：提前获知事务执行结果，读取未提交的结果
    READ-COMMITTED读提交内容：大多数据库的默认隔离级别，读取提交的结果，支持不可重复读，当有事务修改数据后，数据不一致
    REPEATABLE-READ可重复读：MYSQL默认的事务隔离级别，当有事务修改后，数据一致。
    Serializable可串行化：本质上增加乐观锁之类的锁进行隔离，可能导致出现超时现象。

13. 负载均衡：
    软件负载均衡：Nginx、HAProxy、LVS
    硬件负载均衡：在定制处理器上运行的独立负载均衡服务器，主流产品:F5 A10

14. Nginx:负载均衡：

    1. 轮询法：按照时间顺序逐一分配到不同的服务器

    2. weight权重模式：加权轮询，给性能不好的服务器weight降低，灵活分配
    3. ip_hash：每个用户登录上后绑定这个ip到固定服务器，从而保证用户的登录状态。

15. JAVA是伪泛型，泛型擦除：在字节码编译中泛型会被擦除

16. NIO是伪异步，是同步非阻塞

17. 同步、异步、阻塞、非阻塞：
    同步：完成后通过应用程序返回
    异步：完成后通过系统内核返回
    阻塞：处理时，不可以并行处理其他任务
    非阻塞：处理时，可以并行处理其他任务

18. JS本质上是运行在浏览器上的脚本语言，是一个单线程语言，JS的异步能力由JS enviroment提供，将任务添加到执行栈后，栈中的代码调用WebAPI时形成异步任务。

19. 前后端分离项目跨域问题：
    方法一：在SpringBoot后端进行处理：在每个Controller类上加上@CrossOrigin注释
    方法二：在VUE前端进行proxy代理
    方法三：使用nginx或者node.js代理

20. TDD测试驱动开发：编写测试用例（红灯）；编写简单程序让测试通过（绿灯）；重构代码，提高代码可读性与可维护性（美化）

21. Http结构：
    请求报文、响应报文
    请求行：请求方式（post get put...)，请求的资源，协议版本
    请求头：客户端基本信息（Cookie/Host/User-agent......）
    请求体：发送的数据
    相应行：状态码（200：请求成功；301、302：请求重定向，301旧地址已移除；304：请求资源没有变，访问本地缓存；404：请求资源不存在；500：服务器内部错误）
    相应头：服务端信息（Set-Cookie/Server/Location...）
    相应体：页面正文，浏览器加载正文到内存，然后解析渲染显示。

22. 进程间通信方式：1. 匿名管道（单向且必须有亲缘关系） 2. 命名管道（可以实现无亲缘关系的进程通信） 3. 消息队列（消息复制消耗CPU不适合信息量大的场合） 4. 共享存储（无须复制，存在进程同步问题） 5. 信号（复杂）6. 信号量（计数器，控制进程对共享资源的访问，类似于锁）7.Socket（服务器与客户端，Tcp、udp）

23. 线程的同步方式：

    1. 临界区：将多线程串行化访问；只能同步此进程内的线程，其他线程无法同步
    2. 互斥量：只有拥有互斥量的线程才能访问资源；可以同步其他进程的线程，相当于信号量=1
    3. 信号量：允许信号量规定数量的线程访问资源；需要有公共内存，无法用于分布式操作系统
    4. 事件：事件对象可以开启或者关闭共享资源访问的开关，手动置位。

24. 进程调度策略：

    1. 先来先服务
    2. 短作业优先（非抢占式）
    3. 最短剩余时间优先（抢占式）
    4. 时间片轮转
    5. 优先级调度

25. 进程的状态：创建 new 就绪 start 运行 run 阻塞 wait/sleep 死亡 terminated

26. 计算机网络五层协议：1、物理层 2、数据链路层 3、网络层 4、运输层 5、应用层

27. 运输层：UDP TCP 应用层：HTTP {SOCKET是出于应用层与运输层之间的一个协议，WEBSocket是应用层协议}

28. UDP与TCP的区别：![image-20240406193134079](C:\Users\韶光善良君\AppData\Roaming\Typora\typora-user-images\image-20240406193134079.png)

29. http/https是一种面向连接的无状态协议，所谓的无状态指的是，不会对会话设置缓存区，记录会话状态。

30. 三次握手（HTTP建立连接）：1.客户端发送请求连接 2.服务器收到请求，返回同意 3.客户端收到服务器确认后，向服务器发送确认信号
    为什么一定要三次握手：这样可以让服务端和客户端都验证双方的发送和接收能力都是正常的，如果只有两次的话，服务端会不知道客户端的接收能力和自己的发送能力是否正常。

31. SYN 洪泛攻击：在第二次握手与第三次握手之间的状态叫做半连接状态，此时服务器处于等待客户端确认状态，会持续不断重发请求直至成功。SYN攻击就是伪造大量不存在的ip发送http请求，让服务器不断重发，导致系统崩溃。
    检测：当服务器上存在大量的半连接状态，且ip是随机的，基本上就可以断定这是一次SYN攻击。
    防范：1. 通过防火墙过滤网关  2. 增加最大半连接数，缩短超时时间  3. SYN cookie技术。

32. 四次挥手（HTTP关闭连接）：1. 客户端发送连接释放请求FIN报文 2. 服务端收到请求后，返回确认信号ACK报文，同时等待服务端关闭连接。 3. 服务端准备好关闭连接后，向客户端发送结束连接请求FIN报文。 4. 客户端收到FIN报文后，发送一个确认包ACK报文，同时等待可能出现要求重传的ACK报文（TIME_WAIT状态），等待2 * MSL时间后若没收到报文，则关闭连接。
    为什么关闭需要四次：因为服务端在收到客户端关闭请求后，可能还有部分数据需要传输，所以不能马上关闭连接。
    为什么是等待2*MSL时间：因为MSL是报文段在网络上存活的最长时间，客户端发送ACK报文1MSL+服务端FIN报文1MSL

33. TCP协议保证可靠性：
    检验和     序列号        滑动窗口         拥塞控制        流量控制

34. 滑动窗口：TCP协议需要对数据进行确认，导致在等待确认应答包环节浪费时间，窗口内允许不需要等待确认应答包而可以继续发送数据包。

35. 拥塞控制：TCP使用四种算法实现：1.慢开始 2.拥塞避免 3.快速重传 4.快速恢复

36. GET与POST请求的区别：POST更加安全，GET不安全通过url或cookie传参，POST把数据放在body中

37. Http的长连接和短连接：
    HTTP1.0短连接：HTTP建立连接后就断开TCP连接，时间很短；
    HTTP1.1长连接：HTTP请求建立后TCP连接不会关闭，会维持一个较长的时间
    无状态指的是每个HTTP请求都是独立的，会话不会主动继承到下一个会话。长连接只是跳过三次握手直接使用之前的tcp连接。

38. HTTP与HTTPS区别：![image-20240406220716811](C:\Users\韶光善良君\AppData\Roaming\Typora\typora-user-images\image-20240406220716811.png)

39. Cookie和Session的区别：
    Cookie保存在客户端浏览器，Session保存在服务器端
    Cookie只能保存ASCII，Session可以存任意数据类型。
    Cookie可设置长时间保存，Session一般失效时间短。
    Cookie保存的数据不能超过4K，Session可存储数据远高于Cookie

40. 分布式Session问题：

    1. Session复制，服务器将自己的session数据传给其他服务器，使每个服务器都有全部数据
    2. 客户端存储，将用户信息保存在客户端（浏览器）cookie 中。
    3. hash一致性：Nginx负载均衡时，采用Ip-hash策略，让同一个客户端每次请求绑定一个服务器处理
    4. 统一存储：使用Redis第三方中间件来存储用户信息。

41. DDos攻击：分布式拒绝服务攻击，类似于SYN洪水攻击，都是发送拒绝请求，导致服务器持续等待

42. XSS攻击：跨站脚本，渲染html时，将攻击者的数据文本读作了代码运行。比如论坛注入<script>标签

43. SQL注入：用户在输入字段加入SQL语句，导致数据库信息泄露。
    避免方法：限制数据库权限、对进入数据库的特殊字符进行转义处理、提供参数化查询接口，不要直接使用原生SQL

